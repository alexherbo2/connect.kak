#!/bin/sh

# Option parser
# For the simplicity of parsing, we only parse the first argument.
wait=false
case "$1" in
  -wait) wait=true; shift ;;
esac

commands=''
regex=''
while test $# -gt 0; do
  file=$(realpath "$1")
  # Optional coordinates
  case "$2" in
    +*:*)
      line=${2#+}; line=${line%:*}
      column=${2#*:}
      shift 2
      commands="edit %{$file} $line $column; $commands"
      ;;
    +*)
      line=${2#+}
      shift 2
      commands="edit %{$file} $line; $commands"
      ;;
    *)
      shift
      commands="edit %{$file}; $commands"
      ;;
  esac
  regex="${regex}|\\Q${file}\\E"
done
regex=${regex#|}

send "$commands"

if test "$wait" = true; then
  state=$(mktemp -d)
  trap 'rm -Rf "$state"' EXIT
  mkfifo "$state/status"
  send "
    hook -group connect-detach global BufWritePost $regex %{
      remove-hooks global connect-detach
      delete-buffer %val{hook_param}
      echo -to-file $state/status 0
    }
    hook -group connect-detach global BufClose $regex %{
      remove-hooks global connect-detach
      echo -to-file $state/status 1
    }
  "
  read status < "$state/status"
  exit "$status"
fi
